# Arrow Protocol v3

The Arrow Protocol version 3 is a complete redesign of the protocol taking
learnings from the previous versions. In order to simplify the implementation
and improve load balancing on the server side, we separate individual service
sessions from a single multiplexed connection into standalone service session
connections leaving the primary connection to be used only for initiating
service sessions and exchanging other control messages. This removes the need
for multiplexing and it also simplifies the flow control mechanisms. The
Control Protocol is based on JSON-RPC 2.0 with custom framing in order to make
extending the protocol easier in the future.

## Contents

* [1. Glossary](#1-glossary)
* [2. High-level operation overview](#2-high-level-operation-overview)
* [3. Common message structure](#3-common-message-structure)
  * [3.1. Error message](#31-error-message)
  * [3.2. Ping/Pong message](#32-pingpong-message)
* [4. Control Protocol](#4-control-protocol)
  * [4.1. Control Protocol Hello message](#41-control-protocol-hello-message)
  * [4.2. Redirect message](#42-redirect-message)
  * [4.3. Control Protocol Options message](#43-control-protocol-options-message)
  * [4.4. JSON-RPC 2.0 Request/Response/Notification messages](#44-json-rpc-20-requestresponsenotification-messages)
    * [4.4.1. The `connect` method](#441-the-connect-method)
    * [4.4.2. The `add_service` method](#442-the-add_service-method)
    * [4.4.3. The `reset_service_table` method](#443-the-reset_service_table-method)
    * [4.4.4. The `scan_network` method](#444-the-scan_network-method)
    * [4.4.5. The `get_status` method](#445-the-get_status-method)
    * [4.4.6. The `get_last_scan_report` method](#446-the-get_last_scan_report-method)
    * [4.4.7. The `update_service_table` notification](#447-the-update_service_table-notification)
  * [4.5. Control Protocol handshake](#45-control-protocol-handshake)
* [5. Service Protocol](#5-service-protocol)
  * [5.1. Service Protocol Hello message](#51-service-protocol-hello-message)
  * [5.2. Service Protocol Options message](#52-service-protocol-options-message)
  * [5.3. Raw Data message](#53-raw-data-message)
  * [5.4. Raw Data Acknowledgement message](#54-raw-data-acknowledgement-message)
  * [5.5. Service Protocol handshake](#55-service-protocol-handshake)

## 1. Glossary

* **Arrow client**: An Arrow client is a software component running in a local
  network providing Angelcam Cloud access to local services.
* **Control Protocol**: The Control Protocol is a JSON-RPC 2.0 based protocol
  used for managing service sessions between Arrow clients and Arrow servers.
  It is a part of the Arrow Protocol v3.
* **Service Protocol**: The Service Protocol is a simple TCP proxy protocol
  used for forwarding traffic between Angelcam Cloud and local services. It is
  a part of the Arrow Protocol v3.
* **Service session**: A service session represents a single TCP connection
  between Angelcam Cloud and a local service. Each service session is
  established on demand by the Arrow client when requested by the Arrow server
  using the Control Protocol.

## 2. High-level operation overview

The main purpose of the Arrow Protocol is to provide access to local services
from Angelcam Cloud. These services could normally be behind a NAT or a
firewall making it difficult to access them directly. Each Arrow client is
essentially a TCP proxy that forwards traffic between Angelcam Cloud and local
services.

There are two types of connections in Arrow Protocol v3:

* _Control Protocol connection_: Every client is responsible for maintaining a
  single Control Protocol connection to an Arrow server. The Control Protocol
  is used mainly for initiating new service session connections. Both sides act
  as a JSON-RPC 2.0 service and a client at the same time.
* _Service session connections_: Service session connections are created on
  demand by the client when the server requests a new service session using the
  Control Protocol connection. Each service session connection is dedicated to
  a single service session and is closed when the service session ends.

Both the Control Protocol connection and the service session connections are
encrypted using TLS v1.2 or higher to ensure the confidentiality and integrity
of the data being transmitted.

The following diagram illustrates the high-level operation of Arrow Protocol
v3:

```plaintext
+------------------+                                 +------------------+
|   Arrow Client   |                                 |   Arrow Server   |
|                  |                                 |                  |
|  +------------+  |                                 |  +------------+  |
|  | Control    |  |        Control Protocol         |  | Control    |  |
|  | Protocol   | <-----------------------------------> | Protocol   |  |
|  | Connection |  |                                 |  | Connection |  |
|  +------------+  |                                 |  +------------+  |
|         |        |                                 |        |         |
|         |        |         Connect Request         |        |         |
|         |-------------------------------------------------> |         |
|         |        |                                 |        |         |
|         |        |                                 |        |         |
|         |        |                                 |        |         |
|         |        |                                 |        |         |
|  +------------+  |                                 |  +------------+  |
|  | Service    |  |         Service Protocol        |  | Service    |  |
|  | Session    | <-----------------------------------> | Session    |  |
|  | Connection |  |                                 |  | Connection |  |
|  +------------+  |                                 |  +------------+  |
|         |        |                                 |        |         |
|         |        |                                 |        |         |
|         |        |                                 |        |         |
|         |        |                                 |        |         |
+------------------+                                 +------------------+
```

## 3. Common message structure

All multi-byte integer fields defined below are encoded using the network byte
order, and all Arrow Protocol v3 messages have the following basic structure:

```plaintext
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +----------------+---------------+------------------------------+
 0 |    version     |      kind     |          size[31:16]         |
   +----------------+---------------+------------------------------+
 4 |          size[15:0]            |            body ...          |
   +--------------------------------+------------------------------+
 8 |                           ... body ...                        |
   ~                                                               ~
   +---------------------------------------------------------------+
 N |                       ... body                 |
   +---------------------------------------------------------------+
```

where:

* `version` (8-bit unsigned integer): Protocol version. Current version is
    `0x03`.
* `kind` (8-bit unsigned integer): Message kind. There are different message
    kinds for Control Protocol and Service Protocol messages. See below.
* `size` (32-bit unsigned integer): Size of the message body in bytes.
* `body` (variable size): Message body. The content and format of the message
    body depends on the message kind.

The following message kinds are common for both Control Protocol and Service
Protocol:

* `0x02`: Error message
* `0x06`: Ping message
* `0x07`: Pong message

### 3.1. Error message

The error message body consists of a single byte containing the error code.
When an error message is received, the connection should be terminated
immediately. The following error codes are defined:

* `0x00` - _Unsupported protocol version_: Sent by either peer to indicate that
    they received a message with an unsupported protocol version.
* `0x01` - _Unauthorized_: Sent by the server to indicate that the client is
    not allowed to connect. This can happen if the client ID is not paired with
    any user account, the client key is invalid or if the access token used for
    a service session connection is invalid.
* `0x02` - _Unknown message type_: Sent by either peer to indicate that they
    received a message with an unknown message kind.
* `0x03` - _Payload size exceeded_: Sent by either peer to indicate that the
    size of the message body exceeds the allowed limit.
* `0x04` - _Unexpected message type_: Sent by either peer to indicate that they
    received a message kind that is not expected in the current context.
* `0x05` - _Invalid message_: Sent by either peer to indicate that the message
    body is malformed or contains invalid data.
* `0x06` - _Unexpected pong ID_: Sent by either peer to indicate that they
    received a Pong message with an unexpected ID.
* `0x07` - _Too many concurrent requests_: Sent by either peer to indicate that
    the maximum number of concurrent JSON-RPC requests has been exceeded.
* `0x08` - _Unexpected response ID_: Sent by either peer to indicate that they
    received a JSON-RPC response with an unexpected ID.
* `0x09` - _Channel capacity exceeded_: Sent by either peer to indicate that
    the service session channel capacity has been exceeded (i.e. the other
    peer sent more unacknowledged data than allowed).
* `0xff` - _Internal server error_: Sent by the server to indicate that an
    internal error occurred and it is unable to continue with the
    communication.

### 3.2. Ping/Pong message

The message body of both Ping and Pong messages consists of a single 16-bit
integer ID. Each peer has its own sequence of Ping IDs and the other peer
simply echoes the received ID in the Pong message. Ping messages can be sent
periodically by either peer to check if the other peer is still responsive.

## 4. Control Protocol

In addition to the common messages defined above, the Control Protocol defines
the following message kinds:

* `0x00`: Control Protocol Hello message
* `0x03`: Redirect message
* `0x04`: Control Protocol Options message
* `0x10`: JSON-RPC 2.0 Request message
* `0x11`: JSON-RPC 2.0 Response message
* `0x12`: JSON-RPC 2.0 Notification message

### 4.1. Control Protocol Hello message

The Hello message has the following structure:

```plaintext
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------------------------------------------------------+
 0 |                        client_id[0..3]                        |
   +---------------------------------------------------------------+
 4 |                        client_id[4..7]                        |
   +---------------------------------------------------------------+
 8 |                        client_id[8..11]                       |
   +---------------------------------------------------------------+
12 |                        client_id[12..15]                      |
   +---------------------------------------------------------------+
16 |                        client_key[0..3]                       |
   +---------------------------------------------------------------+
20 |                        client_key[4..7]                       |
   +---------------------------------------------------------------+
24 |                        client_key[8..11]                      |
   +---------------------------------------------------------------+
28 |                        client_key[12..15]                     |
   +---------------------------------------------------------------+
32 |                        client_mac[0..3]                       |
   +--------------------------------+------------------------------+
36 |        client_mac[4..5]        |          flags[31:16]        |
   +--------------------------------+------------------------------+
40 |           flags[15:0] (big-endian continuation)               |
   +---------------------------------------------------------------+
42 |                extended_info bytes (arbitrary length)         |
   ~                               ...                             ~
   +---------------------------------------------------------------+
 N |  ... extended_info bytes ...   | 0x00 (NUL terminator) |
   +---------------------------------------------------------------+
```

where:

* `client_id` (16 bytes): A UUIDv4 identifying the Arrow client. The client
    ID is generated by the client upon first startup and should be persisted
    across restarts.
* `client_key` (16 bytes): A random 128-bit key used for client authentication.
    Similarly to `client_id`, the client key is generated by the client upon
    first startup and should be persisted across restarts.
* `client_mac` (6 bytes): The MAC address of the Arrow client. This is used as
    an auxiliary identifier for the client. If the client has multiple network
    interfaces, the MAC address of the primary interface should be used.
* `flags` (32-bit unsigned integer): Client flags. Possible flags are:
  * `0x00000001`: Flag indicating that the client can be used as a gateway,
      i.e. it can connect to services in its local network in addition to
      provided localhost services.
* `extended_info` (variable size): Optional extended information about the
    client. A null-terminated, UTF-8 encoded string containing a JSON object
    is expected. Currently we define the following fields:
  * `client` (object):
    * `id` (string): Identifier of the Arrow client implementation.
    * `version` (string): Version of the Arrow client.
    * `vendor` (string): Vendor of the Arrow client.
  * `device` (object):
    * `category` (string): Device category (e.g. "gateway", "ipc, "nvr", etc.).
    * `type` (string): Device type and/or model (e.g. "angelcam-angelbox-v2").
    * `vendor` (string): Device vendor (e.g. "angelcam", "goodcam", etc.).

### 4.2. Redirect message

The Redirect message contains a single null-terminated, UTF-8 encoded string
representing the new server address. The address can be either an IP address or
a hostname followed by a port number and separated by a colon (e.g.
`m1-eu3.angelcam.com:8901`). When a redirect message is received, the client
should close the current Control Protocol connection immediately and establish
a new connection to the specified address.

### 4.3. Control Protocol Options message

The Options message is used to define limits for the entire connection. Each
peer can define its own limits for the connection and the other peer MUST
respect it. The Options message has the following structure:

```plaintext
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------------------------------------------------------+
 0 |                         max_payload_size                      |
   +---------------------------------------------------------------+
 4 |     max_concurrent_requests   |
   +---------------------------------------------------------------+
```

where:

* `max_payload_size` (32-bit unsigned integer): Maximum allowed size of the
    message body in bytes. If a message with a larger body size is received, an
    error message with code `0x03` (_Payload size exceeded_) should be sent and
    the connection should be terminated.
* `max_concurrent_requests` (16-bit unsigned integer): Maximum number of
    concurrent JSON-RPC requests allowed. Each peer should count the number of
    received requests that have not yet been responded to. If the number of
    concurrent requests exceeds this limit, an error message with code `0x07`
    (_Too many concurrent requests_) should be sent and the connection should
    be terminated.

### 4.4. JSON-RPC 2.0 Request/Response/Notification messages

The JSON-RPC 2.0 Request, Response and Notification messages contain a single
UTF-8 encoded string representing a JSON-RPC 2.0 message. The string is not
null-terminated and its length is determined by the `size` field in the message
header.

There is a few differences compared to the standard JSON-RPC 2.0 messages:

1. The `id` field in the Request and Response messages is always a 64-bit
   unsigned integer and each peer maintains its own sequence of request IDs.
2. Positional parameters are not supported. Only named parameters (i.e. JSON
   objects) are allowed.
3. Batch requests and responses are not allowed. The underlying Control
   Protocol supports message pipelining, so multiple requests can be sent and
   processed concurrently without the need for batching.

The following JSON-RPC 2.0 methods are defined for the Control Protocol client:

* `connect`
* `add_service`
* `reset_service_table`
* `scan_network`
* `get_status`
* `get_last_scan_report`

and the following notifications are defined for the Control Protocol server:

* `update_service_table`

There are no methods defined for the Control Protocol server.

#### 4.4.1. The `connect` method

The `connect` method is used by the server to request the client to establish
a new service session connection. The method has the following parameters:

* `service_id` (integer): 16-bit identifier of the service to connect to.
* `proxy_service` (string): Address of the Arrow server where the service
    session connection should be established. The address is in the form of
    a hostname or an IP address followed by a port number and separated by a
    colon (e.g. `m1-eu3.angelcam.com:8901`).
* `access_token` (string): Access token used for authenticating the service
    session connection.

After establishing the service session connection to the given Arrow server and
successfully connecting to the target local service, the client MUST respond
with a JSON-RPC 2.0 response containing a `result` field with value `null`. If
the connection could not be established, the client MUST respond with a
JSON-RPC 2.0 error response containing an appropriate error code and message.

#### 4.4.2. The `add_service` method

The `add_service` method is used by the server to request access to a new
service. It can be used to request access to services that weren't discovered
automatically using the service discovery mechanism used by the client. The
client should validate the request and reject it if the requested service
should not be accessible. The rules for validating the requested service are
entirely up to the client implementation.

The method has the following parameters:

* `kind` (string): Service type. See the `update_service_table` notification
    below for possible values.
* `host` (string): IPv4 address of the service.
* `port` (integer): Service TCP port number.
* `path` (string): RTSP/MJPEG stream path. It is required only for `rtsp`,
    `rtsp_unsupported` and `mjpeg` service kinds. It is optional for the
    remaining RTSP/MJPEG service kinds. It has no meaning for the other service
    kinds. The parameter MUST be present even if it is not used. Empty string
    should be used in such case.

If the client accepts the request to add the service, it should add the service
to its service table and respond with a JSON-RPC 2.0 response containing a
result object with the following fields:

* `service_id` (integer): 16-bit identifier of the newly added service.

If the client rejects the request to add the service, it MUST respond with a
JSON-RPC 2.0 error response containing an appropriate error code and message.

#### 4.4.3. The `reset_service_table` method

The `reset_service_table` method is used by the server to request the client to
remove all services from its service table with the exception of _static
services_ (i.e. services configured to be always available; implementation
dependent).

There are no parameters for this method. Upon successful completion, the client
MUST respond with a JSON-RPC 2.0 response containing a `result` field with
value `null`. No error conditions are defined for this method.

#### 4.4.4. The `scan_network` method

The `scan_network` method is used by the server to request the client to
perform a network scan in order to discover available services in the local
network. The client should perform the scan asynchronously and send the
results back to the server using the `update_service_table` notification.

There are no parameters for this method. Upon successful initiation of the
network scan, the client MUST respond with a JSON-RPC 2.0 response containing
a `result` field with value `null`. No error conditions are defined for this
method. If the client does not support network scanning, it should still
respond with a successful response.

#### 4.4.5. The `get_status` method

The `get_status` method is used by the server to request the current status of
the client. The method has no parameters. Upon successful completion, the
client MUST respond with a JSON-RPC 2.0 response containing a result object
with the following fields:

* `is_scanning` (boolean): Indicates whether the client is currently
    performing a network scan.
* `active_sessions` (integer): Number of currently active service sessions.

No error conditions are defined for this method.

#### 4.4.6. The `get_last_scan_report` method

The `get_last_scan_report` method is used by the server to request the report
of the last completed network scan. The method has no parameters. The client
MUST respond with a JSON-RPC 2.0 response containing a result object with the
following fields:

* `hosts` (array): An array of discovered hosts. Each host is represented
    by an object with the following fields:
  * `arp_scan` (boolean): Indicates whether the host was discovered using
      ARP scanning.
  * `icmp_scan` (boolean): Indicates whether the host was discovered using
      ICMP echo (i.e. ping) scanning.
  * `mac` (string): Host MAC address in the standard format of six
      hexadecimal octets separated by colons (e.g. `01:23:45:67:89:ab`).
  * `ip` (string): IPv4 address of the host.
  * `ports` (array): An array of open ports on the host. Each port is
      represented by a 16-bit unsigned integer.
* `services` (array): An array of discovered services. Each service is
    represented by an object with the following fields:
  * `service_id` (integer): 16-bit identifier of the service.
  * `type` (string): Service type (see the `update_service_table` notification
      below for possible values).
  * `mac` (string): Service MAC address in the standard format of six
      hexadecimal octets separated by colons (e.g. `01:23:45:67:89:ab`).
  * `host` (string): IP address of the service.
  * `port` (integer): Service TCP port number.
  * `path` (string): Optional service endpoint. The string should be empty if
      it is not applicable for the service type.

If the client has never performed a network scan since the last restart, the
`hosts` and `services` arrays should be empty.

#### 4.4.7. The `update_service_table` notification

The `update_service_table` notification is used by the client to inform the
server about changes in its service table. The notification has the following
parameters:

* `services` (array): An array of services in the client's service table. Each
    service is represented by an object with the following fields:
  * `service_id` (integer): 16-bit identifier of the service.
  * `type` (string): Service type. The following service types are defined:
    * `rtsp`: An RTSP service that does not require user authentication.
    * `rtsp_locked`: An RTSP service that requires user authentication.
    * `rtsp_unknown`: An RTSP service where the exact stream endpoint is not
        known.
    * `rtsp_unsupported`: An RTSP service with known stream endpoint but
        unsupported features (e.g. unsupported audio/video codec).
    * `http`: An HTTP service.
    * `mjpeg`: An MJPEG over HTTP service that does not require user
        authentication.
    * `mjpeg_locked`: An MJPEG over HTTP service that requires user
        authentication.
    * `tcp`: An arbitrary TCP service.
  * `mac` (string): Service MAC address in the standard format of six
      hexadecimal octets separated by colons (e.g. `01:23:45:67:89:ab`). If the
      MAC address is not known, a fake MAC address derived from the service IP
      address prefixed with `ff:ff` should be used.
  * `host` (string): IP address of the service.
  * `port` (integer): Service TCP port number.
  * `path` (string): RTSP/HTTP endpoint. It is required only for `rtsp`,
      `rtsp_unsupported` and `mjpeg` services. It is optional for the remaining
      RTSP/MJPEG services. It has no meaning for the other service types. The
      parameter MUST be present even if it is not used. Empty string should be
      used in such case.

### 4.5. Control Protocol handshake

The Control Protocol handshake is performed immediately after establishing a
new TLS connection between the client and the server. The handshake consists of
the following steps:

1. The client sends a Control Protocol Hello message to the server.
2. The server responds either with a Control Protocol Options message or an
   Error message.
3. If the server responded with the Options message, the client responds with
   its own Control Protocol Options message.

After this handshake is complete, both peers can start sending JSON-RPC
requests, responses, notifications and Ping/Pong messages. Error messages can
also be sent at any time. The server may also send a Redirect message to the
client.

If the client received the Unauthorized error message during the handshake, it
should retry the handshake after a suitable delay (e.g. 5 seconds). If the
client receives only Unauthorized error messages for the duration of 20
minutes, it should suspend its operation indefinitely. The client MUST NOT send
more than 100 Control Protocol Hello messages during any 20-minute period.

If the client received any other error message during the handshake or after
the handshake is complete, it should close the connection immediately and
retry the handshake after a suitable delay (e.g. 60 seconds). The same thing
applies if the connection is terminated unexpectedly. If the connection gets
closed after the handshake is complete, the first retry should happen
immediately.

## 5. Service Protocol

In addition to the common messages defined above, the Service Protocol defines
the following message kinds:

* `0x01`: Service Protocol Hello message
* `0x05`: Service Protocol Options message
* `0x20`: Raw Data message
* `0x21`: Raw Data Acknowledgement message

### 5.1. Service Protocol Hello message

The Service Protocol Hello message consists of a single null-terminated, UTF-8
encoded string representing the access token used for authenticating the
service session connection.

### 5.2. Service Protocol Options message

The Options message is used to define limits for the entire connection. Each
peer can define its own limits for the connection and the other peer MUST
respect it. The Options message has the following structure:

```plaintext
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------------------------------------------------------+
 0 |                         max_payload_size                      |
   +---------------------------------------------------------------+
 4 |                    max_unacknowledged_data                    |
   +---------------------------------------------------------------+
```

where:

* `max_payload_size` (32-bit unsigned integer): Maximum allowed size of the
    message body in bytes. If a message with a larger body size is received, an
    error message with code `0x03` (_Payload size exceeded_) should be sent and
    the connection should be terminated.
* `max_unacknowledged_data` (32-bit unsigned integer): Maximum amount of
    unacknowledged data in bytes that can be sent without receiving a Raw Data
    Acknowledgement message from the other peer. If the amount of
    unacknowledged data exceeds this limit, an error message with code `0x09`
    (_Channel capacity exceeded_) should be sent and the connection should be
    terminated.

### 5.3. Raw Data message

The Raw Data message is used for transmitting raw data between the two peers.
The message body consists of arbitrary binary data to be forwarded to the other
side of the service session.

### 5.4. Raw Data Acknowledgement message

The Raw Data Acknowledgement message is used by each peer to inform the other
peer about the amount of data that has been received and processed. The message
body consists of a single 32-bit unsigned integer _N_ representing the number
of bytes that the peer wishes to acknowledge. The number of acknowledged bytes
is not cumulative. It represents the number of bytes acknowledged since the
last Raw Data Acknowledgement message was sent. The number of acknowledged
bytes may span multiple Raw Data messages and it does not need to correspond to
a Raw Data message boundary. It simply indicates that the peer is ready to
receive N more bytes of data.

### 5.5. Service Protocol handshake

The Service Protocol handshake is performed immediately after establishing a
new TLS service session connection between the client and the server. The
handshake consists of the following steps:

1. The client sends a Service Protocol Hello message to the server.
2. The server responds either with a Service Protocol Options message or an
   Error message.
3. If the server responded with the Options message, the client responds with
   its own Service Protocol Options message.

After this handshake is complete, both peers can start sending Raw Data,
Raw Data Acknowledgement and Ping/Pong messages. Error messages can also be
sent at any time.

The client MUST NOT retry the service session connection if it received an
error message during or after the handshake, or if the connection was closed
after the handshake was complete.

## Revisions

| Revision | Description      |
|----------|------------------|
| `v3.0.0` | initial revision |
